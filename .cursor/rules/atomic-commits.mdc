# Atomic Commits

Encourages minimal, focused commits that accomplish one specific goal with clear, testable changes.

<rule>
name: atomic_commits
description: Promote single-purpose commits with minimal changes to accomplish specific targets
filters:
  - type: file_extension
    pattern: "\\.(js|jsx|ts|tsx|json|md|css)$"
  - type: event
    pattern: "file_save|file_create"

actions:
  - type: suggest
    message: |
      ## ‚öõÔ∏è Atomic Commit Guidelines

      ### Single Purpose Principle
      Each commit should accomplish **one specific goal** with the minimal changes necessary. If you can't describe your commit in a single, clear sentence, it's probably too large.

      ### Manual Commit Creation (No Interactive Tools)
      **IMPORTANT**: Always create commits manually using `git commit -m "message"` format.
      - **DO NOT** use interactive commit tools like `npm run commit` or `git cz`
      - **DO** manually craft commit messages following conventional commit format
      - **DO** ensure commit messages are clear and descriptive

      ### Conventional Commit Format
      All commits must follow this exact format:
      ```
      <type>(<scope>): <subject>
      
      <body>
      
      <footer>
      ```

      **Required Elements:**
      - **type**: One of feat, fix, docs, style, refactor, test, chore
      - **subject**: Clear, concise description (50 characters max)
      - **body**: Optional detailed explanation (72 characters per line)
      - **footer**: Optional breaking changes or issue references

      **Examples:**
      ```bash
      git commit -m "feat: add route input validation"
      git commit -m "fix: correct map marker positioning"
      git commit -m "docs: update installation instructions"
      git commit -m "test: add unit tests for scoring service"
      ```

      ### Atomic Commit Checklist
      Before committing, ask yourself:
      - [ ] **Single Purpose**: Does this commit do exactly one thing?
      - [ ] **Minimal Changes**: Are these the smallest changes needed for this goal?
      - [ ] **Self-Contained**: Could this commit be safely reverted without breaking other features?
      - [ ] **Testable**: Can I test this specific change in isolation?
      - [ ] **Clear Message**: Can I describe this change in one clear sentence?
      - [ ] **Manual Creation**: Am I creating this commit manually with proper format?

      ### What Makes a Good Atomic Commit
      
      **‚úÖ GOOD Examples:**
      ```
      feat: add route input validation
      fix: correct map marker positioning
      docs: update installation instructions
      test: add unit tests for scoring service
      refactor: extract map styling to separate CSS file
      style: fix ESLint warnings in Game component
      ```

      **‚ùå TOO LARGE Examples:**
      ```
      feat: implement complete Google Maps integration with scoring and UI
      fix: various bugs and add new features
      refactor: reorganize project structure and update documentation
      ```

      ### Atomic Commit Categories

      **üÜï feat**: New feature (single feature only)
      - Add one component
      - Add one service method
      - Add one utility function
      - Implement one user story

      **üêõ fix**: Bug fix (single bug only)
      - Fix one specific issue
      - Correct one error condition
      - Resolve one failing test

      **üìö docs**: Documentation change
      - Update one document
      - Add documentation for one feature
      - Fix one documentation error

      **üß™ test**: Test addition or modification
      - Add tests for one component/function
      - Fix one failing test
      - Add one test scenario

      **‚ôªÔ∏è refactor**: Code improvement without behavior change
      - Extract one function/component
      - Rename one set of related items
      - Reorganize one module

      **üíÑ style**: Code formatting/linting
      - Fix ESLint issues in one file
      - Format one component
      - Fix one style inconsistency

      **üîß chore**: Maintenance task
      - Update one dependency
      - Add one script
      - Configure one tool

      ### Change Size Guidelines

      **Ideal Atomic Commit:**
      - **Files**: 1-3 files maximum
      - **Lines**: < 50 lines of changes (excluding generated files)
      - **Scope**: Single component, function, or concern
      - **Time**: Should take < 30 minutes to review

      **Warning Signs (Too Large):**
      - **Files**: > 5 files changed
      - **Lines**: > 100 lines of changes
      - **Mixed Concerns**: Touches multiple unrelated areas
      - **Complex Message**: Commit message needs multiple sentences

      ### Breaking Down Large Changes

      **Instead of one large commit:**
      ```
      feat: implement complete game flow with maps, scoring, and UI
      ```

      **Break into atomic commits:**
      ```
      1. feat: add Google Maps API integration service
      2. feat: create Map display component
      3. feat: add route input component with validation
      4. feat: implement basic scoring algorithm
      5. feat: create Game orchestration component
      6. test: add unit tests for scoring service
      7. test: add E2E tests for complete game flow
      8. docs: update README with new features
      ```

      ### Testing Atomic Commits

      **Each commit should:**
      - Pass all existing tests
      - Include tests for new functionality
      - Be independently testable
      - Not break the build

      **Quick validation:**
      ```bash
      # Before committing each atomic change
      npm run test:all:dev    # Fast feedback
      npm run lint           # Code quality
      ```

      ### Atomic Commit Workflow

      **1. Plan Your Changes**
      - Identify the specific goal
      - List the minimal files/functions to change
      - Break down into 1-3 file changes max

      **2. Make Minimal Changes**
      - Change only what's necessary
      - Avoid "while I'm here" changes
      - Save related but separate improvements for another commit

      **3. Test Independently**
      - Verify this specific change works
      - Run tests to ensure no regressions
      - Test the change in isolation if possible

      **4. Commit Manually with Clear Message**
      - Use `git commit -m "type: clear description"` format
      - Follow conventional commit format exactly
      - Keep message concise and specific
      - **Never** use interactive commit tools

      **5. Move to Next Atomic Change**
      - Resist the urge to bundle changes
      - Each commit should stand alone
      - Build features incrementally

      ### Manual Commit Examples for Our Project

      **Component Development:**
      ```bash
      git commit -m "feat: add Map component with basic Google Maps display"
      git commit -m "feat: add RouteInput component with text validation"
      git commit -m "style: fix ESLint warnings in Map component"
      ```

      **Service Implementation:**
      ```bash
      git commit -m "feat: implement route scoring algorithm in scoring service"
      git commit -m "refactor: extract map utilities to separate service"
      git commit -m "fix: correct distance calculation in scoring service"
      ```

      **Testing:**
      ```bash
      git commit -m "test: add unit tests for Map component"
      git commit -m "test: add E2E tests for route input flow"
      git commit -m "fix: resolve failing test in scoring service"
      ```

      **Documentation:**
      ```bash
      git commit -m "docs: update QA.md with new testing patterns"
      git commit -m "docs: add API documentation for maps service"
      git commit -m "docs: update README with development progress"
      ```

      ### Working with Our Codebase

      **Current Structure Supports Atomic Commits:**
      - **Components**: Each in separate files (`src/components/`)
      - **Services**: Isolated business logic (`src/services/`)
      - **Tests**: Co-located with source files
      - **Documentation**: Separate files for different concerns

      ### Benefits of Atomic Commits
      - **Easier Reviews**: Small, focused changes are easier to understand
      - **Safer Reverts**: Can revert specific features without affecting others
      - **Better Debugging**: Git bisect works better with atomic changes
      - **Cleaner History**: Clear progression of feature development
      - **Parallel Work**: Team members can work on different atomic changes
      - **Quality Gates**: Each commit can be independently validated

      ### Integration with Pre-commit Hooks
      Our README enforcer works perfectly with atomic commits:
      - Small code changes = small documentation updates
      - Clear commit purpose = clear documentation updates
      - Independent changes = independent documentation sections

      ### Commit Message Standards
      **Format Requirements:**
      - Start with lowercase type (feat, fix, docs, etc.)
      - Use imperative mood ("add" not "adds" or "added")
      - No period at the end of subject line
      - Keep subject line under 50 characters
      - Reference issues with "fixes #123" or "closes #123"

      **Quality Checklist:**
      - [ ] Follows conventional commit format
      - [ ] Created manually (not with interactive tools)
      - [ ] Single purpose and minimal changes
      - [ ] Clear, descriptive message
      - [ ] All tests pass before committing

examples:
  - input: "Adding complete Google Maps integration with UI and scoring"
    output: "Break into: 1) feat: add Google Maps API service, 2) feat: create Map component, 3) feat: add scoring logic, 4) test: add comprehensive tests"
  - input: "Fixing multiple bugs and adding new feature"
    output: "Separate into individual commits: fix: resolve marker positioning, fix: correct route validation, feat: add new feature"

metadata:
  priority: high
  version: 1.1
  category: "development-workflow"
</rule>


  category: "development-workflow"
</rule>

